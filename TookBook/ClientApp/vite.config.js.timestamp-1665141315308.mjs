// vite.config.js
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import fs from "fs";
import path from "path";
import { execSync } from "child_process";
var vite_config_default = defineConfig({
  plugins: [react()],
  server: {
    port: 3e3,
    strictPort: true,
    https: generateCerts(),
    proxy: {
      "/api": {
        changeOrigin: true,
        secure: false,
        rewrite: (path2) => path2.replace(/^\/api/, "/api"),
        target: process.env.ASPNETCORE_HTTPS_PORT ? `https://localhost:${process.env.ASPNETCORE_HTTPS_PORT}` : process.env.ASPNETCORE_URLS ? process.env.ASPNETCORE_URLS.split(";")[0] : "http://localhost:40457"
      }
    }
  }
});
function generateCerts() {
  const baseFolder = process.env.APPDATA !== void 0 && process.env.APPDATA !== "" ? `${process.env.APPDATA}/ASP.NET/https` : `${process.env.HOME}/.aspnet/https`;
  const certificateArg = process.argv.map((arg) => arg.match(/--name=(?<value>.+)/i)).filter(Boolean)[0];
  const certificateName = certificateArg ? certificateArg.groups.value : process.env.npm_package_name;
  if (!certificateName) {
    console.error(
      "Invalid certificate name. Run this script in the context of an npm/yarn script or pass --name=<<app>> explicitly."
    );
    process.exit(-1);
  }
  const certFilePath = path.join(baseFolder, `${certificateName}.pem`);
  const keyFilePath = path.join(baseFolder, `${certificateName}.key`);
  if (!fs.existsSync(certFilePath) || !fs.existsSync(keyFilePath)) {
    const outp = execSync(
      "dotnet " + [
        "dev-certs",
        "https",
        "--export-path",
        certFilePath,
        "--format",
        "Pem",
        "--no-password"
      ].join(" ")
    );
    console.log(outp.toString());
  }
  return {
    cert: fs.readFileSync(certFilePath, "utf8"),
    key: fs.readFileSync(keyFilePath, "utf8")
  };
}
export {
  vite_config_default as default
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsidml0ZS5jb25maWcuanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbImNvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9kaXJuYW1lID0gXCJFOlxcXFxVc2Vyc1xcXFxKZXNwZXJcXFxcRG9jdW1lbnRzXFxcXFV0YmlsZG5pbmdcXFxcLk5FVDIxXFxcXE5FVDIxIC0gRnVsbHN0YWNrIENJQ0RcXFxcUHJvamVrdGFyYmV0ZVxcXFxUb29rQm9va1xcXFxUb29rQm9va1xcXFxDbGllbnRBcHBcIjtjb25zdCBfX3ZpdGVfaW5qZWN0ZWRfb3JpZ2luYWxfZmlsZW5hbWUgPSBcIkU6XFxcXFVzZXJzXFxcXEplc3BlclxcXFxEb2N1bWVudHNcXFxcVXRiaWxkbmluZ1xcXFwuTkVUMjFcXFxcTkVUMjEgLSBGdWxsc3RhY2sgQ0lDRFxcXFxQcm9qZWt0YXJiZXRlXFxcXFRvb2tCb29rXFxcXFRvb2tCb29rXFxcXENsaWVudEFwcFxcXFx2aXRlLmNvbmZpZy5qc1wiO2NvbnN0IF9fdml0ZV9pbmplY3RlZF9vcmlnaW5hbF9pbXBvcnRfbWV0YV91cmwgPSBcImZpbGU6Ly8vRTovVXNlcnMvSmVzcGVyL0RvY3VtZW50cy9VdGJpbGRuaW5nLy5ORVQyMS9ORVQyMSUyMC0lMjBGdWxsc3RhY2slMjBDSUNEL1Byb2pla3RhcmJldGUvVG9va0Jvb2svVG9va0Jvb2svQ2xpZW50QXBwL3ZpdGUuY29uZmlnLmpzXCI7aW1wb3J0IHsgZGVmaW5lQ29uZmlnIH0gZnJvbSBcInZpdGVcIjtcclxuaW1wb3J0IHJlYWN0IGZyb20gXCJAdml0ZWpzL3BsdWdpbi1yZWFjdFwiO1xyXG5cclxuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xyXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgeyBleGVjU3luYyB9IGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb25maWcoe1xyXG4gICAgcGx1Z2luczogW3JlYWN0KCldLFxyXG4gICAgc2VydmVyOiB7XHJcbiAgICAgICAgcG9ydDogMzAwMCxcclxuICAgICAgICBzdHJpY3RQb3J0OiB0cnVlLFxyXG4gICAgICAgIGh0dHBzOiBnZW5lcmF0ZUNlcnRzKCksXHJcbiAgICAgICAgcHJveHk6IHtcclxuICAgICAgICAgICAgLy8gcHJveHkgQVBJIHJlcXVlc3RzIHRvIHRoZSBBU1AuTkVUIGJhY2tlbmRcclxuICAgICAgICAgICAgXCIvYXBpXCI6IHtcclxuICAgICAgICAgICAgICAgIGNoYW5nZU9yaWdpbjogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNlY3VyZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICByZXdyaXRlOiAocGF0aCkgPT4gcGF0aC5yZXBsYWNlKC9eXFwvYXBpLywgXCIvYXBpXCIpLFxyXG4gICAgICAgICAgICAgICAgLy8gdGFyZ2V0IHRha2VuIGZyb20gc3JjL3NldHVwUHJveHkuanMgaW4gQVNQLk5FVCBSZWFjdCB0ZW1wbGF0ZVxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBwcm9jZXNzLmVudi5BU1BORVRDT1JFX0hUVFBTX1BPUlRcclxuICAgICAgICAgICAgICAgICAgICA/IGBodHRwczovL2xvY2FsaG9zdDoke3Byb2Nlc3MuZW52LkFTUE5FVENPUkVfSFRUUFNfUE9SVH1gXHJcbiAgICAgICAgICAgICAgICAgICAgOiBwcm9jZXNzLmVudi5BU1BORVRDT1JFX1VSTFNcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwcm9jZXNzLmVudi5BU1BORVRDT1JFX1VSTFMuc3BsaXQoXCI7XCIpWzBdXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJodHRwOi8vbG9jYWxob3N0OjQwNDU3XCIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgfSxcclxuICAgIH0sXHJcbn0pO1xyXG5cclxuLyoqIEZ1bmN0aW9uIHRha2VuIGZyb20gYXNwbmV0Y29yZS1odHRwcy5qcyBpbiBBU1AuTkVUIFJlYWN0IHRlbXBsYXRlICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlQ2VydHMoKSB7XHJcbiAgICBjb25zdCBiYXNlRm9sZGVyID1cclxuICAgICAgICBwcm9jZXNzLmVudi5BUFBEQVRBICE9PSB1bmRlZmluZWQgJiYgcHJvY2Vzcy5lbnYuQVBQREFUQSAhPT0gXCJcIlxyXG4gICAgICAgICAgICA/IGAke3Byb2Nlc3MuZW52LkFQUERBVEF9L0FTUC5ORVQvaHR0cHNgXHJcbiAgICAgICAgICAgIDogYCR7cHJvY2Vzcy5lbnYuSE9NRX0vLmFzcG5ldC9odHRwc2A7XHJcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZUFyZyA9IHByb2Nlc3MuYXJndlxyXG4gICAgICAgIC5tYXAoKGFyZykgPT4gYXJnLm1hdGNoKC8tLW5hbWU9KD88dmFsdWU+LispL2kpKVxyXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilbMF07XHJcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZU5hbWUgPSBjZXJ0aWZpY2F0ZUFyZ1xyXG4gICAgICAgID8gY2VydGlmaWNhdGVBcmcuZ3JvdXBzLnZhbHVlXHJcbiAgICAgICAgOiBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lO1xyXG5cclxuICAgIGlmICghY2VydGlmaWNhdGVOYW1lKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcihcclxuICAgICAgICAgICAgXCJJbnZhbGlkIGNlcnRpZmljYXRlIG5hbWUuIFJ1biB0aGlzIHNjcmlwdCBpbiB0aGUgY29udGV4dCBvZiBhbiBucG0veWFybiBzY3JpcHQgb3IgcGFzcyAtLW5hbWU9PDxhcHA+PiBleHBsaWNpdGx5LlwiXHJcbiAgICAgICAgKTtcclxuICAgICAgICBwcm9jZXNzLmV4aXQoLTEpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNlcnRGaWxlUGF0aCA9IHBhdGguam9pbihiYXNlRm9sZGVyLCBgJHtjZXJ0aWZpY2F0ZU5hbWV9LnBlbWApO1xyXG4gICAgY29uc3Qga2V5RmlsZVBhdGggPSBwYXRoLmpvaW4oYmFzZUZvbGRlciwgYCR7Y2VydGlmaWNhdGVOYW1lfS5rZXlgKTtcclxuXHJcbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMoY2VydEZpbGVQYXRoKSB8fCAhZnMuZXhpc3RzU3luYyhrZXlGaWxlUGF0aCkpIHtcclxuICAgICAgICBjb25zdCBvdXRwID0gZXhlY1N5bmMoXHJcbiAgICAgICAgICAgIFwiZG90bmV0IFwiICtcclxuICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgXCJkZXYtY2VydHNcIixcclxuICAgICAgICAgICAgICAgIFwiaHR0cHNcIixcclxuICAgICAgICAgICAgICAgIFwiLS1leHBvcnQtcGF0aFwiLFxyXG4gICAgICAgICAgICAgICAgY2VydEZpbGVQYXRoLFxyXG4gICAgICAgICAgICAgICAgXCItLWZvcm1hdFwiLFxyXG4gICAgICAgICAgICAgICAgXCJQZW1cIixcclxuICAgICAgICAgICAgICAgIFwiLS1uby1wYXNzd29yZFwiLFxyXG4gICAgICAgICAgICBdLmpvaW4oXCIgXCIpXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zb2xlLmxvZyhvdXRwLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2VydDogZnMucmVhZEZpbGVTeW5jKGNlcnRGaWxlUGF0aCwgXCJ1dGY4XCIpLFxyXG4gICAgICAgIGtleTogZnMucmVhZEZpbGVTeW5jKGtleUZpbGVQYXRoLCBcInV0ZjhcIiksXHJcbiAgICB9O1xyXG59Il0sCiAgIm1hcHBpbmdzIjogIjtBQUFraEIsU0FBUyxvQkFBb0I7QUFDL2lCLE9BQU8sV0FBVztBQUVsQixPQUFPLFFBQVE7QUFDZixPQUFPLFVBQVU7QUFDakIsU0FBUyxnQkFBZ0I7QUFFekIsSUFBTyxzQkFBUSxhQUFhO0FBQUEsRUFDeEIsU0FBUyxDQUFDLE1BQU0sQ0FBQztBQUFBLEVBQ2pCLFFBQVE7QUFBQSxJQUNKLE1BQU07QUFBQSxJQUNOLFlBQVk7QUFBQSxJQUNaLE9BQU8sY0FBYztBQUFBLElBQ3JCLE9BQU87QUFBQSxNQUVILFFBQVE7QUFBQSxRQUNKLGNBQWM7QUFBQSxRQUNkLFFBQVE7QUFBQSxRQUNSLFNBQVMsQ0FBQ0EsVUFBU0EsTUFBSyxRQUFRLFVBQVUsTUFBTTtBQUFBLFFBRWhELFFBQVEsUUFBUSxJQUFJLHdCQUNkLHFCQUFxQixRQUFRLElBQUksMEJBQ2pDLFFBQVEsSUFBSSxrQkFDUixRQUFRLElBQUksZ0JBQWdCLE1BQU0sR0FBRyxFQUFFLEtBQ3ZDO0FBQUEsTUFDZDtBQUFBLElBQ0o7QUFBQSxFQUNKO0FBQ0osQ0FBQztBQUdELFNBQVMsZ0JBQWdCO0FBQ3JCLFFBQU0sYUFDRixRQUFRLElBQUksWUFBWSxVQUFhLFFBQVEsSUFBSSxZQUFZLEtBQ3ZELEdBQUcsUUFBUSxJQUFJLDBCQUNmLEdBQUcsUUFBUSxJQUFJO0FBQ3pCLFFBQU0saUJBQWlCLFFBQVEsS0FDMUIsSUFBSSxDQUFDLFFBQVEsSUFBSSxNQUFNLHNCQUFzQixDQUFDLEVBQzlDLE9BQU8sT0FBTyxFQUFFO0FBQ3JCLFFBQU0sa0JBQWtCLGlCQUNsQixlQUFlLE9BQU8sUUFDdEIsUUFBUSxJQUFJO0FBRWxCLE1BQUksQ0FBQyxpQkFBaUI7QUFDbEIsWUFBUTtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBQ0EsWUFBUSxLQUFLLEVBQUU7QUFBQSxFQUNuQjtBQUVBLFFBQU0sZUFBZSxLQUFLLEtBQUssWUFBWSxHQUFHLHFCQUFxQjtBQUNuRSxRQUFNLGNBQWMsS0FBSyxLQUFLLFlBQVksR0FBRyxxQkFBcUI7QUFFbEUsTUFBSSxDQUFDLEdBQUcsV0FBVyxZQUFZLEtBQUssQ0FBQyxHQUFHLFdBQVcsV0FBVyxHQUFHO0FBQzdELFVBQU0sT0FBTztBQUFBLE1BQ1QsWUFDQTtBQUFBLFFBQ0k7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxRQUNBO0FBQUEsUUFDQTtBQUFBLFFBQ0E7QUFBQSxNQUNKLEVBQUUsS0FBSyxHQUFHO0FBQUEsSUFDZDtBQUNBLFlBQVEsSUFBSSxLQUFLLFNBQVMsQ0FBQztBQUFBLEVBQy9CO0FBRUEsU0FBTztBQUFBLElBQ0gsTUFBTSxHQUFHLGFBQWEsY0FBYyxNQUFNO0FBQUEsSUFDMUMsS0FBSyxHQUFHLGFBQWEsYUFBYSxNQUFNO0FBQUEsRUFDNUM7QUFDSjsiLAogICJuYW1lcyI6IFsicGF0aCJdCn0K
